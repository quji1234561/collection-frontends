# 1 盒子模型

**组成**

- border边框

- content内容

- padding 内边距（边框与内容的距离）

- margin外边距（盒子与盒子之间的距离）

## 1.1 边框

- border-width:边框粗细

- border-style:solid|dashed|dotted边框风格（实线、虚线、点线）eeee

- border-color:

- 复合写法：`border:1px solid red;` 没有顺序。

**也可以只对其中一个边框更改：**

border-top border-left: 这样。

**表格的细线边框**

单元格和单元格之间的边框实际上是两条边框。想要变得更细一点就可以用

`border-collapse:collapse;` 

 **边框会影响盒子大小**

假如盒子是200px\*200px 有一个10px的边框，结果就会变成220px*220px

## 1.2 内边距

- padding-top/left/right/bottom: (内边距大小)

- 复合属性：padding:5px(上下左右都是5像素）
  
  padding:10px 5px(上下10 左右5)  padding:10px 5px 20px(上10 左右5 下20) padding:10px 20px 30px 40px(上 右 下 左（顺时针）)

**padding会影响盒子大小**

假如盒子是200px\*200px 有一个10px的边框，结果就会变成220px*220px.

padding设置好之后，在把盒子的大小减去两倍padding像素就好了。

利用这个特性，可以不设盒子宽度，只设置padding，这样就可以合理调整因内容多少不同而改变的盒子大小了。

如果盒子本身没有指定width/height（而是继承了父标签的宽或长），padding不会撑开盒子大小。

## 1.3 外边距

- margin-top/bottom/right/left

- 简写：与padding一模一样。

**典型应用：**

- <mark>**块级盒子水平居中**</mark>
  
  1. 盒子必须制定了宽度
  
  2. 左右外边距都设置为auto。
     
     `header{width:960px;margin:0 auto;}`
  
  以下三种常见写法都可以
  
  - margin-left:auto;margin right:auto;
  
  - margin:auto;
  
  - **margin:0 auto**;(也就是上下边距为0，左右auto)
  
  如果想让**行内元素或行内块元素居中**，只需要给父标签加一个`<text-align:center>`即可。

## 1.4 常见问题

- **外边距合并**：相邻块的垂直（上下）外边距会冲突，取大的那个，而不是叠加。比如上面的盒子下外边距30，下边的盒子上外边距20，那么他俩的距离是30。所以我们应该只设置其中一个就好了。

- **嵌套块元素塌陷：** 若父块标签没有边框，没有取消浮动时，子块的外边距无法将自身与父块分离。解决方案：
  
  1. 为父块定义边框（透明的也可以）
  
  2. 为父元素定义内边距（总之就是让他与子块分离）
  
  3. 为父元素添加`overflow:hidden;

- **清除内外边距：** 各种网页元素会自带内外边距，如ul li会自带很多的内边距。解决方案：
  
  ```css
  *{
      margin:0px;
      padding:0px;
  }
  ```
  
  星号是作用于全体标签的。（这句话在一个项目前边基本都要加）

- **去掉li前的小圆点**：`list-style:none;`

# 2 CSS3新增

## 2.1 圆角边框

`border-radius:10px;`

后边跟的是圆角的半径。后边也可以跟百分比，50%是一个圆。

想要两边是弧形的圆角矩形：将半径设为高度的一半。

后边可以跟四个数值，分别是左上 右上 右下 左上（顺时针）

## 2.2 盒子阴影

对盒子设置阴影。

`box-shadow:10px 10px 10px 10px black;`

参数分别是：

阴影水平距离、垂直距离、模糊度、阴影尺寸、阴影颜色 （后边也可以加inset表示内阴影）。

一般我们也不太用纯黑色的影子，而是用一种透明度影子（`rgba(0,0,0,.3)`）

盒子阴影不占空间。

- 盒子阴影配合hover非常好看常见！

文字也可以设置阴影`text-shadow:10px 10px 10px black;`

这里没有阴影尺寸。

# 3 css浮动

## 3.1 浮动

布局方式

- 标准流：先前学的流，按照标签默认规定的方式排列

float属性用于创建浮动框，将其移动到一边，直到左右边缘触碰到另一个浮动框的边缘。

最经典的应用：让多个块级元素一行内排列显示

**网页布局第一准则：多个块级元素纵向排列找标准流，横向排列找浮动。**

## 3.2 浮动特性（重要）

最重要的**特性**：

1. 脱离标准普通流的控制（浮起来），移动到指定位置（动起来）（俗称**脱标**）

2. 浮动的盒子**不再保留原先的位置**。

浮起来就类似于图层上升。

如果多个盒子都设置了浮动，就会按照属性值一行内显示，并顶端对齐。

## 3.3浮动具有行内块的特点

任何标签都可以浮动，浮动了的标签就有行内块的特点了。例如：

1. span也可以设置宽高了

2. 块级元素在标准流里不需要设置宽，就和父级一样宽。但一旦浮动，宽度就和内容一样宽了（行内块特点）

3. 浮动的盒子之间没有缝隙

## 3.4 浮动元素经常和标准流父标签搭配使用

一般我们会用标准流的父元素排列上下位置，然后再用浮动排列左右位置，这也符合**网页布局第一准则**。

## 3.5 清除浮动

- 为什么：
  
  父盒子有时因为内容未知，直接设定高度是不合适的。我们希望让子盒的高度把父盒撑开。但若子盒浮动，父盒高度不会因子盒高度变化。因此，我们需要清除浮动。

- 本质：清除浮动元素脱离标准流的影响。

- 策略：闭合浮动，让浮动在父盒内部影响，不影响父盒子外面的盒子（在家里皮，不要在外面皮。）
  
  - **方法**：
    
    1. 额外标签法：隔墙法。在最后一个浮动的子盒后面再加一个盒子，并对这个盒子添加`clear:both/left/right;` 即可。（一般不用，用也只用both），因为额外增加标签了，让结构更复杂了。
    
    2. 给父级添加overflow。`overflow:hidden/auto;` 清除浮动。优点：代码简洁，缺点：无法显示溢出的部分。
    
    3. 给父级添加clearfix类，`:after`伪元素法。
    
    ```css
    .clearfix:after{
        content:"";
        display:block;
        height:0;
        clear:both;
        visibility:hidden;
    }
    .clearfix{
        /*IE6、7专有*/
        *zoom:1;
    }
    ```

                这个代码可以先不理解。类似于额外标签法。优点：没有增加标签，结构简单。缺点：需要照顾低版本浏览器。

                4. 双伪元素清除浮动：（给父元素添加clearfix类）

```css
.clearfix:before,.clearfix:after{
    content:"";
    display:table;
}
.clearfix:after{
    clear:both;
}
.clearfix{
    *zoom:1;
}
```

代码简单，需照顾低版本浏览器。

# 4 PS

jpg格式：颜色好，适合整张图片。

png格式：适合背景透明的图片

gif格式：适合动画。

## 

# CSS书写顺序

顺序决定专业性。

1. 首先写布局定位属性：`display/position/float/clear/visibility/overflow`

2. 自身属性：`width/height/margin/padding/border/background`

3. 文本属性：`color/font/text-decoration/text-align/vertical-align/`

4. css3的其他属性：`content/cursor/border-radius/box-shadow/text-shadow`

# 实战

1. 开始先取消所有盒子的默认边距（`*{margin:0;padding:0;}`）

2. 可以先定一个总体的宽度，然后定义一个宽度和margin 0 auto的类，赋给所有的大盒子。

3. 做导航栏的时候不要用a堆砌，会降低网站在搜索引擎的权重。要用多个li+a的操作。

# 5 定位

## 5.1 为什么要定位

让一个盒子自由移动，不受约束，或不随滚轮而移动，而且可以压住其他盒子。

这都是浮动做不到的，需要定位。

## 5.2 定位组成

定位=定位模式+边偏移。

- **定位模式：** 
  
  - `position:static/relative/absolute/fixed;`
  
  - 静态/相对/绝对/固定

- **边偏移：** 
  
  - `top:/bottom:/left:/right:` 定义元素相对于其父元素的边的距离。

### 静态定位：

是position默认的方式，**按照标准流方式摆放位置**，很少使用。

### 相对定位（重要）

`position:relative;`

相对定位是元素在移动位置时，是相对于他原来的位置来说的（自恋型）。

1. 移动时参照自己原来的位置。

2. 原本的位置不会改变，继续占有，**只是让他的图像移动了一些。** （**不脱标**/不浮动）

3. 主要的作用是**给绝对定位当爹**。

### 绝对定位（重要）

`position:absolute;`

在定位时，是相对于他的父级元素来说的。（拼爹型）

1. 如果**没有祖先元素**，或祖先元素**没有定位**，那绝对定位以**浏览器**为准。

2. 如果祖先元素**有定位**，以祖先元素为准。（以最近一级的有定位的祖先元素为准）

3. 绝对定位不占用原来的位置（**脱标** / 比浮动飘得还要高）。

### 固定定位

`positon:fixed`

页面元素在滚动时，位置不变。（以浏览器的**可视窗口**为参照）

1. 与父元素没有任何关系

2. 不随滚动条而移动。

3. 不占有原先的位置（**脱标**：一种特殊的绝对定位）

技巧：**让固定定位的盒子以版心为参照**

想要完成此操作需要一个**算法**：

```css
position:fixed;
left:50%;
margin-left:600px;(版心宽度的一半)
```

先设定一个left50% 将盒子设定在版心中间，然后再将盒子外边距移动版心的一半，那么这个盒子就以版心为参照固定了。

## 5.3 子绝父相

子盒子用绝对定位，父盒子要用相对定位。

子级用绝对定位，不会影响其他兄弟的位置，可以放在父级的任何地方。

父级用相对定位，占用一定的位置。

## 5.4 粘性定位（了解）

`position:sticky;`

在可视窗口中相对定位，当超出可视窗口时，变为固定定位。

1. 以可视窗口为参照点移动（固定定位的特点）

2. 占有原先的位置（相对定位的特点）

3. 必须添加top/bottom/left/right其中一个。

## 5.5 定位的叠放次序

`z-index:1;`

可以控制盒子的前后顺序。

1. 后边的数字越大，盒子越靠上。

2. 如果数字一样，后来者居上。

3. 只有定位的盒子才能加z-index，后边不能加单位。

## 5.6 拓展

- **绝对定位的盒子居中。**
  
  - 加了绝对定位的盒子不能用`margin:0 auto;`
  
  - 运用一个算法：**1: left走50%. 2: margin负值往左边走绝对盒子的一半。**

- 特殊特性：
  
  - 绝对定位和固定定位和浮动类似.
    
    - 行内元素添加绝对/固定定位，可以设置高度和宽度
    
    - 块级元素添加绝对/固定定位，不给宽度时默认是内容的大小。
    
    - 脱标的盒子不会外边距塌陷

- 绝对/固定定位会完全压住盒子（而浮动不会压住下面的文字和图片，因为浮动本身就是为了文字环绕效果的。）

# 6 flex布局

用定位来完成居中效果，这也太不优雅了！

~~**1: left走50%. 2: margin负值往左边走绝对盒子的一半。**~~

这也太tm猥琐了。我们要优雅！所以就有flex布局了！

## 6.1 基本概念

### 6.1.1 父容器

在定义了`display:flex;`之后，就可以对父容器添加以下属性：

- **justify-content**

`justify-content:flex-start/flex-end/center/space-around/space-between` 

     在这个容器内的所有子盒子沿**主轴**分布方式（主轴默认为横轴）其中前三个为位置排列，后两个为分布排列。

意思分别为：

顶端对齐、末尾对齐、居中对齐、子容器均匀分布、子容器均匀分布且首尾两个与父容器相切。

- **align-items**

`align-items:flex-start/flex-end/center/baseline/stretch;`

    在这个容器内的所有盒子沿**交叉轴**分布方式（默认为竖轴）

意思分别为：

顶端对齐、末尾对齐、居中对齐、基线对齐（子容器中的文字对齐）、子容器拉伸至与父容器一致。

### 6.1.2 子容器

（前提仍是父容器含`display:flex;`）

- **flex**

在主轴上如何伸缩。后可跟0~3个值。

子容器**主轴**：

**单值：** 宽、高：`flex-basis:30px/auto/content/50%;`  

        在没有考虑剩余空间分配时候，预定义一个大小。auto表示项目初始尺寸由内容决定。百分数代表占父容器的比值。

             无单位：`flex-grow:1/2;` （扩展比例，通常多个盒子同时使用，表示盒子空间的比例）

**两值：** `flex-grow|flex-basis:1 30px;` 扩展比例+像素

            `flex-grow|flex:shink:1 1;` 扩展比例+收缩比例

**三值：** `flex-grow|flex-shink|flex-basis:1 1 10%;` 扩展比例+收缩比例、像素。

**无值：** `flex:0 0 auto；`

子容器**交叉轴**：

`align-self:flex-start/flex-end/center/baseline/stretch;`

对子容器单独作用的起始、末端、居中、基线对齐。（stretch是拉伸）

### 6.1.3 轴

**轴** 包括 **主轴** 和 **交叉轴**，我们知道 `justify-content` 属性决定子容器沿主轴的排列方式，`align-items` 属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中：

`flex-direction` 属性决定主轴的方向，交叉轴的方向由主轴确定。

向右：`flex-direction: row`

向下：`flex-direction: column`

向左：`flex-direction: row-reverse`

向上：`flex-direction: column-reverse`

主轴逆时针旋转90°即为交叉轴。

## 6.2 进阶概念

### 6.2.1 父容器

- 设置换行方式：**flex-wrap**
  
  决定子容器是否换行排列，不但可以顺序换行而且支持逆序换行。
  
  `flex-wrap:nowrap/wrap/wrap-reverse;` 不换行、换行、逆序换行。

- 轴向与换行**组合设置**(复合写法)：**flex-flow**

flow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行，比如 `flex-flow: row wrap`，`flex-flow` 是一个复合属性，相当于 flex-direction 与 flex-wrap 的组合，可选的取值如下：   

- `row`、`column` 等，可单独设置主轴方向

- `wrap`、`nowrap` 等，可单独设置换行方式

- `row nowrap`、`column wrap` 等，也可两者同时设置

- 多行沿交叉轴对齐：**align-content**
  
  当子容器多行排列时，设置行与行之间的对齐方式。属性值同样为
  
  `flex-start/flex-end/center/baseline/stretch;`

### 6.2.2 子容器

- 设置排列顺序：**order**
  
  改变子容器的排列顺序，覆盖 HTML 代码中的顺序，默认值为 0，可以为负值，数值越小排列越靠前。

<img title="" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/0dd26d8e99257ff36443.png~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="" data-align="center">
